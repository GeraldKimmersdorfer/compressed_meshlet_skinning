#version 460
#extension GL_EXT_shader_16bit_storage   : require
#extension GL_EXT_shader_8bit_storage    : require
#extension GL_EXT_mesh_shader            : require
#extension GL_EXT_nonuniform_qualifier   : require
#extension GL_GOOGLE_include_directive	 : require

#include "glsl_helpers.glsl"
#include "shared_structs.glsl"

layout (constant_id = 0) const uint NUM_TASK_SHADER_INVOCATIONS = 1; // <- Expected to be set to 32 for Nvidia on host side.
layout (constant_id = 1) const uint NUM_MESH_SHADER_INVOCATIONS = 1; // <- Expected to be set to 32 for Nvidia on host side.
layout(local_size_x_id = 1, local_size_y = 1, local_size_z = 1) in;
// The max_vertices and max_primitives numbers have been recommended by Nvidia:
layout(triangles, max_vertices = 64, max_primitives = 126) out;

taskPayloadSharedEXT uint meshletIndices[NUM_TASK_SHADER_INVOCATIONS];

layout(set = 0, binding = 1) uniform CameraBuffer { camera_data camera; };
layout(set = 3, binding = 0) uniform  samplerBuffer positionsBuffer;
layout(set = 3, binding = 2) uniform  samplerBuffer normalsBuffer;
layout(set = 3, binding = 3) uniform  samplerBuffer texCoordsBuffer;
layout(set = 4, binding = 0) buffer MeshletsBuffer { extended_meshlet meshlets[]; };
layout(set = 4, binding = 1) buffer MeshBuffer { mesh_data meshes[]; };

// Mesh shader output block:
layout (location = 0) out PerVertexData
{
	vec3 positionWS;
	vec3 normalWS;
	vec2 texCoord;
	flat int materialIndex;
	vec3 color;
} v_out[];

void main() 
{
	uint meshletIndex = meshletIndices[gl_WorkGroupID.x];
	uint invocationId = gl_LocalInvocationID.x;

	// Get all the meshlet data:
	mesh_data mesh = meshes[meshlets[meshletIndex].mMeshIndex];
	uint vertexCount          = uint(meshlets[meshletIndex].mGeometry.mVertexCount);
	uint triangleCount        = uint(meshlets[meshletIndex].mGeometry.mTriangleCount);
	uint materialIndex        = mesh.mMaterialIndex;
	mat4 transformationMatrix = mesh.mTransformationMatrix;
	
	// Step by NUM_MESH_SHADER_INVOCATIONS as we have that many threads but potentially more vertices to calculate:
	for (uint i = invocationId; i < vertexCount; i += NUM_MESH_SHADER_INVOCATIONS)
	{
		// Get the vertex index:
		int vi = int(meshlets[meshletIndex].mGeometry.mVertices[i] + mesh.mVertexOffset);
		// Get vertex data from the appropriate texel buffers and vertex indices:
		vec4 posMshSp = vec4(texelFetch(positionsBuffer, vi).xyz, 1.0);
		vec3 nrmMshSp = texelFetch(normalsBuffer, vi).xyz;

		// Standard transformation:
		vec4 posWS = transformationMatrix * posMshSp;
		vec4 posCS = camera.mViewProjMatrix * posWS;
 
		// Set the vertex position:
		gl_MeshVerticesEXT[i].gl_Position = posCS;
 
		// Set the per vertex data for the fragment shader:
		v_out[i].positionWS = posWS.xyz;
		v_out[i].normalWS = mat3(transformationMatrix) * nrmMshSp;
		v_out[i].texCoord = texelFetch(texCoordsBuffer, vi).st;
		v_out[i].materialIndex = int(materialIndex);
		v_out[i].color = color_from_id_hash(meshletIndex);
	}
 
	// Sets the actual output size of the primitives and vertices that the 
	// mesh shader workgroup will emit upon completion:
	SetMeshOutputsEXT(vertexCount, triangleCount);
	// ^ Note: This is the correct way and place to call SetMeshOutputsEXT, as the spec says:
	// 
	// > The arguments are taken from the first invocation in each workgroup. 
	// > Any invocation must execute this instruction no more than once and 
	// > under uniform control flow. There must not be any control flow path 
	// > to an output write that is not preceded by this instruction.
 
	// Write for each triangle, also note the NUM_MESH_SHADER_INVOCATIONS stepping
	for (uint i = invocationId; i < triangleCount; i += NUM_MESH_SHADER_INVOCATIONS)
	{
		// Write the indices for the vertices:
		gl_PrimitiveTriangleIndicesEXT[i] = uvec3(
			meshlets[meshletIndex].mGeometry.mIndices[i * 3 + 0],
			meshlets[meshletIndex].mGeometry.mIndices[i * 3 + 1],
			meshlets[meshletIndex].mGeometry.mIndices[i * 3 + 2]
		);
	}
}
